<<<<<<< HEAD
# 2-3-1 옵티마이저와 실행계획



# 1. 옵티마이저

\- 옵티마이저 : 사용자가 질의한 SQL문에 대해 최적의 실행 방법을 결정하는 역할

\- 관계형 데이터베이스는 SQL문을 통해서 데이터 처리가 가능한데, 다양한 실행 방법 중 최적의 실행 방법을 결정하는 것이 옵티마이저의 역할이다

\- 옵티마이저가 선택한 실행 방법의 적절성 여부는 질의 수행 속도에 가장 큰 영향을 준다

**가. 규칙기반 옵티마이저(RBO, Rule Based Optimizer)**

\- 우선순위를 기준으로 실행 계획을 생성한다

\- 실행 계획을 생성할 때 참조하는 정보에는 인덱스(SQL문 실행하기 위해 이용 가능한 유일/비유일/단일/복합 인덱스)의 유무와 종류, SQL문에서 사용하는 연산자(=, <, >, like, BETWEEN 등), SQL문에서 참조하는 객체(힙 테이블, 클러스터 테이블 등)

| **순위** | **액세스 기법**                                           |
| -------- | --------------------------------------------------------- |
| **1**    | Single row by rowid                                       |
| **2**    | Single row by cluster join                                |
| **3**    | Single row by hash cluster key with unique or primary key |
| **4**    | Single row by unique or primary key                       |
| **5**    | Cluster join                                              |
| **6**    | Hash cluster key                                          |
| **7**    | Indexed cluster key                                       |
| **8**    | Composite index                                           |
| **9**    | Single column index                                       |
| **10**   | Bounded range search on indexed columns                   |
| **11**   | Unbounded range search on indexed columns                 |
| **12**   | Sort merge join                                           |
| **13**   | Max or Min of indexed column                              |
| **14**   | ORDER BY on inedexed column                               |
| **15**   | Full table scan                                           |

\- RBO는 인덱스를 이용한 액세스 방식이 전체 테이블 액세스 방식보다 우선순위가 높다

\- RBO가 조인 순서를 결정할 때 조인 칼럼 인덱스의 존재 유무가 중요한 판단 기준이다. 만약 조인하는 양쪽 테이블에 모두 인덱스가 존재한다면, 우선 순위가 높은 테이블을 선행 테이블로 선택한다. 만약 한쪽에만 인덱스가 존재한다면 인덱스가 없는 테이블을 선행 테이블로 선택해서 수행한다

**나. 비용기반 옵티마이저(CBO, Cost Based Optimizer)**

\- SQL문을 처리하는 데 필요한 비용(SQL문을 처리하기 위해 예상되는 소요시간 또는 자원 사용량)이 가장 적은 실행계획을 선택하는 방식이다

\- 비용을 예측하기 위해 CBO가 사용하지 않는 테이블, 인덱스, 컬럼 등의 다양한 객체 통계정보와 시스템 통계정보를 이용한다

\- 따라서 정확한 통계 정보를 유지하는 것이 CBO 성능 측면에서 매우 중요하다

\- CBO의 구성요소 3가지

1) 질의 변환기 : 사용자가 작성한 SQL문을 처리하기에 보다 용이한 형태로 변환하는 모듈

2) 대안 계획 생성기 : 동일한 결과를 생성하는 다양한 대안 계획을 생성하는 모듈

\- 대안 계획 : 연산의 적용 순서 변경, 연산 방법 변경, 조인 순서 변경 등을 통해서 생성

3) 비용 예측기 : 대안 계획 생성기에 의해 생성된 대안 계획의 비용을 예측하는 모듈



# 2. 실행계획

\- SQL에서 요구한 사항을 처리하기 위한 절차와 방법

\- 실행계획을 생성하는 것은 SQL을 어떤 순서로 어떻게 실행할지 결정하는 작업

\- 실행 계획을 구성하는 요소 5가지

1) 조인 순서 : 조인작업을 수행할 때 참조하는 테이블의 순서

2) 조인 기법 : 두 테이블을 조인할 때 사용할 수 있는 방법(NL Join, Hash Join, Sort Merge Join 등 존재)

3) 액세스 기법 : 하나의 테이블을 액세스할 때 사용하는 방법(Index Scan, Full Table Scan 등 존재)

4) 최적화 정보 : 옵티마이저가 실행계획의 각 단계마다 예상되는 비용 사항을 표시한 것(CBO로 실행계획 생성)

\- 최적화 정보에는 cost(상대적인 비용), card(주어진 조건을 만족하는 결과 집합 혹은 조인 조건을 만족하는 결과 집합의 건수), bytes(결과 집합이 차지하는 메모리 양을 바이트로 표시한 것)가 있다

5) 연산 : 여러가지 조작을 통해 원하는 결과를 얻어내는 일련의 작업



# 3. SQL 처리 흐름도

=======
# 2-3-1 옵티마이저와 실행계획



# 1. 옵티마이저

\- 옵티마이저 : 사용자가 질의한 SQL문에 대해 최적의 실행 방법을 결정하는 역할

\- 관계형 데이터베이스는 SQL문을 통해서 데이터 처리가 가능한데, 다양한 실행 방법 중 최적의 실행 방법을 결정하는 것이 옵티마이저의 역할이다

\- 옵티마이저가 선택한 실행 방법의 적절성 여부는 질의 수행 속도에 가장 큰 영향을 준다

**가. 규칙기반 옵티마이저(RBO, Rule Based Optimizer)**

\- 우선순위를 기준으로 실행 계획을 생성한다

\- 실행 계획을 생성할 때 참조하는 정보에는 인덱스(SQL문 실행하기 위해 이용 가능한 유일/비유일/단일/복합 인덱스)의 유무와 종류, SQL문에서 사용하는 연산자(=, <, >, like, BETWEEN 등), SQL문에서 참조하는 객체(힙 테이블, 클러스터 테이블 등)

| **순위** | **액세스 기법**                                           |
| -------- | --------------------------------------------------------- |
| **1**    | Single row by rowid                                       |
| **2**    | Single row by cluster join                                |
| **3**    | Single row by hash cluster key with unique or primary key |
| **4**    | Single row by unique or primary key                       |
| **5**    | Cluster join                                              |
| **6**    | Hash cluster key                                          |
| **7**    | Indexed cluster key                                       |
| **8**    | Composite index                                           |
| **9**    | Single column index                                       |
| **10**   | Bounded range search on indexed columns                   |
| **11**   | Unbounded range search on indexed columns                 |
| **12**   | Sort merge join                                           |
| **13**   | Max or Min of indexed column                              |
| **14**   | ORDER BY on inedexed column                               |
| **15**   | Full table scan                                           |

\- RBO는 인덱스를 이용한 액세스 방식이 전체 테이블 액세스 방식보다 우선순위가 높다

\- RBO가 조인 순서를 결정할 때 조인 칼럼 인덱스의 존재 유무가 중요한 판단 기준이다. 만약 조인하는 양쪽 테이블에 모두 인덱스가 존재한다면, 우선 순위가 높은 테이블을 선행 테이블로 선택한다. 만약 한쪽에만 인덱스가 존재한다면 인덱스가 없는 테이블을 선행 테이블로 선택해서 수행한다

**나. 비용기반 옵티마이저(CBO, Cost Based Optimizer)**

\- SQL문을 처리하는 데 필요한 비용(SQL문을 처리하기 위해 예상되는 소요시간 또는 자원 사용량)이 가장 적은 실행계획을 선택하는 방식이다

\- 비용을 예측하기 위해 CBO가 사용하지 않는 테이블, 인덱스, 컬럼 등의 다양한 객체 통계정보와 시스템 통계정보를 이용한다

\- 따라서 정확한 통계 정보를 유지하는 것이 CBO 성능 측면에서 매우 중요하다

\- CBO의 구성요소 3가지

1) 질의 변환기 : 사용자가 작성한 SQL문을 처리하기에 보다 용이한 형태로 변환하는 모듈

2) 대안 계획 생성기 : 동일한 결과를 생성하는 다양한 대안 계획을 생성하는 모듈

\- 대안 계획 : 연산의 적용 순서 변경, 연산 방법 변경, 조인 순서 변경 등을 통해서 생성

3) 비용 예측기 : 대안 계획 생성기에 의해 생성된 대안 계획의 비용을 예측하는 모듈



# 2. 실행계획

\- SQL에서 요구한 사항을 처리하기 위한 절차와 방법

\- 실행계획을 생성하는 것은 SQL을 어떤 순서로 어떻게 실행할지 결정하는 작업

\- 실행 계획을 구성하는 요소 5가지

1) 조인 순서 : 조인작업을 수행할 때 참조하는 테이블의 순서

2) 조인 기법 : 두 테이블을 조인할 때 사용할 수 있는 방법(NL Join, Hash Join, Sort Merge Join 등 존재)

3) 액세스 기법 : 하나의 테이블을 액세스할 때 사용하는 방법(Index Scan, Full Table Scan 등 존재)

4) 최적화 정보 : 옵티마이저가 실행계획의 각 단계마다 예상되는 비용 사항을 표시한 것(CBO로 실행계획 생성)

\- 최적화 정보에는 cost(상대적인 비용), card(주어진 조건을 만족하는 결과 집합 혹은 조인 조건을 만족하는 결과 집합의 건수), bytes(결과 집합이 차지하는 메모리 양을 바이트로 표시한 것)가 있다

5) 연산 : 여러가지 조작을 통해 원하는 결과를 얻어내는 일련의 작업



# 3. SQL 처리 흐름도

>>>>>>> bac486b0f38872d8328c1454556236eb8c1145c0
\- SQL 내부적인 처리 절차를 시각적으로 표현(조인 순서, 조인 기법, 액세스 기법 등을 포함)한 도표