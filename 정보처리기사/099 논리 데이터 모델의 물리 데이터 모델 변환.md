

# [정보처리기사 099] - 논리 데이터 모델의 물리 데이터 모델 변환 ★



# **# 테이블**

데이터를 저장하는 DB의 가장 기본적인 오브젝트



· **로우** : Row, 튜플, 인스턴스, 어커런스

· **컬럼** : 각 속성 항목에 대한 값 저장

· **기본 키** : Main Key, 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성

· **외래 키** : 다른 릴레이션의 기본 키를 참조하는 속성 또는 속성들의 집합



# **# 엔티티를 테이블로 변환**

논리 데이터 모델에서 정의된 엔티티를 물리 데이터 모델의 테이블로 변환하는 것



· 엔티티를 테이블로 변환 후 테이블 목록 정의서 작성

· 테이블 목록 정의서 : 테이블 목록, 전체 테이블을 목록으로 요약 관리하는 문서

<img src='/img/099_01.png'>

<center>출처 : http://www.dbguide.net/db.db?cmd=view&boardUid=12860&boardConfigUid=9&categoryUid=216&boardIdx=42&boardStep=1</center>



· 변환 규칙

| **논리적 설계(데이터 모델링)** | **물리적 설계**    |
| ------------------------------ | ------------------ |
| 엔티티, Entity                 | 테이블, Table      |
| 속성, Attribut                 | 컬럼, Column       |
| 주 식별자, Primary ID          | 기본 키, PK        |
| 외부 식별자, Foreign ID        | 외래 키, FK        |
| 관계, Relationship             | 관계, Relationship |



<img src='/img/099_02.png'>

<center>출처 : http://www.dbguide.net/db.db?cmd=view&boardUid=12860&boardConfigUid=9&categoryUid=216&boardIdx=42&boardStep=1</center>



· 변환 시 고려 사항

​    \- 일반적으로 테이블과 엔티티 명칭은 동일하게 유지하는 것을 권고

​    \- 엔티티는 주로 한글이지만 테이블은 소스코드 가독성을 위해 영문 사용

​    \- 메타 데이터 관리 시스템에 표준화 된 용어가 있을 시, 그 단어를 사용하여 명명



# **# 슈퍼타입/서브타입을 테이블로 변환**

논리 데이터 모델에서 이용되는 형태인 슈퍼/서브타입을 물리 데이터 모델로 설계할 때 테이블로 변환해야 한다.



**[슈퍼타입 기준 테이블 변환]**

· 서브타입을 슈퍼타입에 통합하여 하나의 테이블로 만드는 것

· 서브타입에 속성이나 관계가 적을 경우에 적용하는 방법

· 하나로 통합된 테이블에는 서브타입의 모든 속성이 포함되어야 함

· 장점 : 데이터 액세스 용이, 뷰를 이용한 각각의 서브타입만을 액세스 하거나 수정 가능, 서브타입 구분이 없는 임의 집합에 대한 처리 용이, 여러 테이블을 조인하지 않아도 되므로 수행 속도 빠름,  단순한 SQL 문장 구성

· 단점 : 테이블 컬럼이 증가에 따른 디스크 저장 공간 증가, 처리마다 서브타입에 대한 구분이 필요한 경우가 발생, 인덱스 크기 증가로 인한 인덱스 효율 저하



**[서브타입 기준 테이블 변환]**

· 슈퍼타입 속성들을 각각의 서브타입에 추가하여, 서브타입들을 개별 테이블로 만드는 것

· 서브타입에 속성이나 관계가 많이 포함된 경우 적용하는 방법

· 장점

​    \- 각 서브타입 속성들의 선택 사양이 명확한 경우 유리

​    \- 처리할 때마다 서브타입 유형을 구분할 필요가 없음

​    \- 여러 테이블로 통합하기 때문에 테이블 당 크기가 감소하여 전체 테이블 스캔 시 유리

· 단점

​    \- 수행 속도 감소

​    \- 복잡한 처리를 위한 SQL 통합의 어려움

​    \- 부분 범위에 대한 처리 곤란

​    \- 여러 테이블을 통합한 뷰는 조회만 가능, 식별자의 유지 관리가 어려움



**[개별 타입 기준 테이블 변환]**

· 슈퍼타입과 서브타입들을 각각의 개별적 테이블로 변환하는 것

· 슈퍼타입과 서브타입 테이블 사이에 각 1대1 관계가 형성된다.

· 개별 타입 기준 테이블 변환을 적용하는 경우

​    \- 전체 데이터에 대한 처리가 빈번한 경우

​    \- 서브타입의 처리가 대부분 독립적으로 발생하는 경우

​    \- 통합 테이블의 컬럼 수가 많은 경우

​    \- 서브 타입의 컬럼수가 많은 경우

​    \- 트랜잭션이 주로 슈퍼타입에서 발생하는 경우

​    \- 퓨서타입 처리 범위가 넓고 빈번하게 발생하여 단인 테이블 클러스터링이 필요한 경우

· 장점

​    \- 저장 공간이 상대적으로 작다.

​    \- 슈퍼타입 또는 서브타입 각각의 테이블에 속한 정보만 조회하는 경우 용이한 문장 작성

· 단점

​    \- 슈퍼타입과 서브타입을 같이 처리하면 조인이 발생하여 성능이 떨어짐



# **# 속성을 컬럼으로 변환**

논리 데이터 모델에서 정의한 속성을 물리 데이터 모델의 컬럼으로 변환한다.



**[일반 속성 변환]**

· 속성과 컬럼 명칭은 반드시 일치할 필요는 없으나, 개발자와 사용자 간 의사소통을 위해 가능한 한 표준화 된 약어를 사용해 일치시키는 것이 좋다.

· 컬럼명은 SQL의 예약어를 피하고, 또한 가독성을 높이기 위해 가능한 한 짧게 지정한다.

· 복합 단어를 컬럼며으로 사용할 때는 미리 정의된 표준을 따른다.

· 테이블의 컬럼을 정의한 후에는 한 로우에 해당하는 샘플 데이터를 작성해 컬럼의 정합성을 검증한다.



**[Primary UID를 기본 키로 변환]**

· 논리 데이터 모델에서의 Primary UID는 물리 데이터 모딜의 기본 키로 만든다.



**[Primary UID(관계의 UID Bar)를 기본 키로 변환]**

· 다른 엔티티와의 관계로 인해 생성된 Primary UID는 물리 데이터 모델의 기본 키로 만든다.



**[Secondary(Alternate) UID를 유니크 키로 변환]**

· 논리 모델링에서 정의된 Secondary UID 및 Alternate Key는 물리 데이터 모델에서 유니크 키로 만든다.



# **# 관계를 외래키러 변환**

논리 데이터 모델에서 정의된 관계는 기본 키와 이를 참조하는 외래 키로 변환한다.



**[E-R 모델을 관계 테이블로 변환]**

· 1:1 관계 : 개체 A의 기본 키를 개체 B의 외래 키로 추가하거나, 개체 B의 기본 키를 개체 A의 외래키로 추가하여 표현한다.

· 1:M 관계 : 개체 A의 기본 키를 개체 B의 외래키로 추가하여 표현하거나, 별도의 테이블로 표현한다.

· N:M 관계 : 릴레이션 A와 B의 기본 키를 모두 포함하는 별도의 릴레이션으로 표현한다. 이 때 생성된 별도의 릴레이션을 교차 릴레이션 또는 교차 엔티티라고 한다.

· 1:M 순환 관계 : 개체 A에 개체 A의 기본 키를 참조하는 외래 키 컬럼을 추가해 표현한다. 주로 데이터의 계층 구조를 표현하기 위해 사용된다.



# **# 관리 목적의 테이블/컬럼 추가**

논리 데이터 모델에는 존재하지 않는 테이블이나 컬럼을 DB 관리 혹은 DB를 이용하는 프로그래밍 수행 속도 향상을 위해 물리 데이터 모델에 추가하는 것이다.

​    ex) 시스템 등록 일자, 시스템 번호 등



# **# 데이터 타입 선택**

논리 데이터 모델에서 정의된 논리적 데이터 타입을 물리적인 DBMS의 물리적 특성과 성능을 고려해 최적의 데이터 타입과 데이터의 최대 길이를 선택한다.



· 주요 타입 : 문자(Chaacter), 숫자(Numeric), 날짜(Date)

· Oracle에서 대표 데이터 유형

​    \- CHAR : 고정길이 문자열 Data, 최대 2,000 Byte까지 저장 가능

​    \- VARCHAR2 : 가변길이 문자열 Data, 최대 4,000 Byte까지 저장 가능

​    \- NUMBER : 38자릿수의 숫자 저장 가능

​    \- DATE : 날짜 저장