# [정보처리기사 020] - 소프트웨어 아키텍쳐 ★



# **# 소프트웨어 아키텍처의 설계**

소프트웨어의 뼈대가 되는 기본 구조이며, 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템 구조 또는 구조체이다.

소프트웨어 개발 시 적용되는 원칙과 지침이며, 이해 관계자의 의사소통 도구로 활용된다.

좋은 품질을 유지하면서 사용자의 기능적 요구사항을 구현하는 방법과, 비기능적 요구사항으로 나타낸 제약을 반영하는 과정이다.



# **# 소프트웨어 아키텍처 설계의 기본 원리**

**1) 모듈화(Modularity)**

​        · 소프트웨어의 성능을 향상시키거나 시스템 수정 및 재사용, 유지 관리 등의 작업이 용이하도록 시스템의 기능을 모듈 단위로 나누는 것을 의미한다.

​        · 자주 사용되는 기능들을 공통 모듈로 구성하여 프로젝트의 재사용성을 향상시킨다.

​        · 모듈 크기가 너무 작으면 모듈 개수가 많아져 통합 비용이 많이 들고, 크게 나누면 모듈 하나 당 개발 비용이 많이 든다.

**2) 추상화(Abstraction)**

​        · 불필요한 부분을 생략하고 필요한 부분만 강조하여 모델화 하는 것이다.

​        · 즉, 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것이다.

​        · 완전한 시스템 구축 전 그 시스템과 유사한 모델을 만들어 여러 테스트를 진행한다.

​        · 최소 비용으로 실제 상황에 대처할 수 있고, 시스템 구조 및 구성을 대략적으로 파악할 수 있게 해준다.

​        · 유형 : **과정 추상화**(자세한 수행 과정을 정의하지 않고, 전반적 흐름만 파악할 수 있도록 설계), **데이터 추상화**(데이터의 세부적인 속성과 용도는 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체), **제어 추상화**(이벤트 발생의 정확한 절차나 방법은 정의하지 않고, 대표할 수 있는 표현으로 대체)

**3) 단계적 분해(Stepwise Refinement)**

​        · 하향실 설계 전략으로, 문제를 상위 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법이다.

​        · 추상화의 반복에 의해 세분화 된다.

​        · 소프트웨어의 기능에서부터 시작하여 점차적으로 구체화한다.

​        · 알고리즘, 자료구조 등 상세한 내역은 가능한 한 뒤로 미루고 진행한다.

**4) 정보 은닉(Information Hiding)**

​        · 한 모듈 내에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법이다.

​        · 정보 은닉을 통해 모듈을 독립적으로 수행할 수 있고, 하나의 모듈이 변경되더라도 다른 모듈에 영향을 주지 않는다.

​        · 이로써 수정, 시험, 유지보수가 용이한 것이다.



# **# 소프트웨어 아키텍처의 품질 속성**

소프트웨어 아키텍처가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계 되었는지 확인하는 것이다.



품질 평가 요소들을 3가지 측면으로 구분하여 구체화시켜 놓았다.

**1) 시스템 측면**

​        · 성능 : 사용자 요청 등 이벤트가 발생했을 때, 적절하고 빠르게 처리하는 것

​        · 보안 : 허용되지 않은 접근을 막고, 허용 접근에는 적절한 서비스를 제공하는 것

​        · 가용성 : 장애 없이 정상적으로 서비스를 제공하는 것

​        · 기능성 : 사용자가 요구한 기능을 만족스럽게 구현하는 것

​        · 사용성 : 사용자가 소프트웨어 사용 시 헤매지 않도록 명확하고 편리하게 구현하는 것

​        · 변경 용이성 : 소프트웨어가 처음 목표에서 변경 되거나, 다른 HW나 플랫폼에서도 동작될 수 있도록 구현하는 것

​        · 확장성 : 시스템의 용량, 처리 능력 등을 확장시켰을 때 효과적으로 활용할 수 있도록 구현하는 것

​        · 기타 속성 : 테스트 용이성, 배치성, 안정성 등

**2) 비즈니스 측면**

​        · 시장 적시성 : 정해진 시간에 맞춰 프로그램을 출시하는 것

​        · 비용과 혜택 : 개발 비용을 더 투자하여 유연성 높은 아키텍처를 만들지 결정하는 것, 유연성이 떨어지는 소프트웨어는 유지보수에 많은 비용이 소모되는 것을 고려

​        · 예상 시스템 수명 : 시스템을 얼마나 오래 사용할 것인지 고려하는 것, 수명이 길어지기 위해서는 변경 용이성과 확장성을 고려해야 함

​        · 기타 속성 : 목표 시장, 공개 일정, 기존 시스템과의 통합 등

**3) 아키텍처 측면**

​        · 개념적 무결성 : 전체 시스템과 시스템을 이루는 구성요소 간 일관성을 유지하는 것

​        · 정확성&완결성 : 요구사항과 요구사항을 구현하기 위해 발생하는 제약사항들을 모두 충족시키는 것

​        · 구축 가능성 : 모듈 단위로 구분된 시스템을 적절하게 분배하여 유연하게 일정을 변경하는 것

​        · 기타 속성 : 변경성, 시험성, 적응성, 일치성, 대체성 등



# **# 소프트웨어 아키텍처 설계 과정**

**1) 설계 목표 설정**

​        · 시스템 개발 방향을 명확히 하기 위해 시스템 설계 목표를 설정한다.

​        · 설계에 영향을 주는 비즈니스 목표, 우선순위 등의 요구사항을 분석한다.

**2) 시스템 타입 결정**

​        · 시스템과 서브시스템의 타입을 결정하고, 설계 목표와 함께 고려하여 아키텍처 패턴을 선택한다.

​        · 여기서 아키텍처 패턴은 다양한 문제 해결을 위한 전형적인 해결 방식을 의미한다.

​        · 시스템 타입 유형 : **대화형 시스템**(사용자 요구에 따라 시스템이 처리하고 반응하는 시스템), **이벤트 중심 시스템**(외부 상태 변화에 따라 동작하는 시스템), **변환형 시스템**(데이터가 입력되면 정해진 작업을 수행하여 결과를 출력하는 시스템), **객체 영속형 시스템**(DB를 사용하여 파일을 효과적으로 저장/검색/갱신하는 시스템)

**3) 아키텍처 패턴 적용**

​        · 아키텍처 패턴을 참조하여 시스템 표준 아키텍처를 설계한다.

**4) 서브시스템 구체화**

​        · 서브시스템의 기능 및 서브시스템 간의 상호작용을 위한 동작과 인터페이스를 정의한다.

**5) 검토**

​        · 아키텍처가 설계 목표에 부합하는지, 요구사항이 잘 반영되었는지, 설계 기본 원리를 만족하는지 등을 검토한다.