# [정보처리기사 026] - 디자인 패턴 ☆



# **# 디자인 패턴(Design Pattern)의 개요**

각 모듈의 세분화된 역할이나 모듈 간 인터페이스와 같은 코드를 작성하는 수준에서, 세부적인 구현 방안을 설게할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미한다.

개발 과정 중 문제가 발생하면 새롭게 해결책을 구상하는 것보다는 그 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적이다.



디자인 패턴은 재사용할 수 있는 기본형 코드들이 포함되어 있다.

한 패턴에 변형을 주거나 특정 요구사항을 반영하면 유사한 형태의 다른 패턴으로 변화되는 특징이 있다.



**[아키텍처 패턴 vs 디자인 패턴]**

· 둘 다 소프트웨어 설계를 위한 참조 모델이다.

· 아키텍처 패턴은 디자인 패턴보다 상위 수준의 설계에 사용된다.

· **아키텍처 패턴**이 전체 시스템의 구조를 설계하기 위한 참조 모델이면, **디자인 페턴**은 서브시스템에 속하는 컴포넌트와 그 관계를 설계하기 위한 참조 모델이다.



# **# 생성(Creational) 패턴**

객체의 생성과 참조 과정을 캡슐화 하여 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 주지 않도록 하여 프로그램의 유연성을 더해준다.

| **추상 팩토리****(Abstract Factory)** | · 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관/의존하는 객체들의 그룹으로 생성하여 추상적으로 표현한다.· 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능하다. |
| ------------------------------------- | ------------------------------------------------------------ |
| **빌더****(Builder)**                 | · 작게 분리된 인스턴스를 조합하여 객체를 생성한다.· 객체의 생성 과정과 표현 방법을 분리하기 때문에 동일 객체 생성의 결과도 다를 수 있다. |
| **팩토리 메소드****(Factory Method)** | · 객체 생성을 서브 클래스에서 처리하도록 캡슐화한 패턴이다.· 상위 클래스에서 인터페이스만 정의하고, 실제 생성은 서브 클래스가 담당한다. |
| **프로토타입****(Prototype)**         | · 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴이다.· 일반적인 방법으로 객체를 생성하며, 비용이 큰 경우 적절하다. |
| **싱글톤****(Singleton)**             | · 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수 없다.· 클래스 내에 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화 할 수 있다. |



# **# 구조(Structural) 패턴**

클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게하는 패턴이다.

| **어댑터****(Adapter)**         | · 호환성 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴이다. |
| ------------------------------- | ------------------------------------------------------------ |
| **브리지****(Bridge)**          | · 기능과 구현을 두 개의 클래스로 별도 구현한다.· 구현 클래스에서 추상층을 분리하고, 서로가 독립적으로 확장할 수 있도록 구성한 패턴이다. |
| **컴포지트****(Composite)**     | · 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다룰 때 사용하는 패턴이다.· 객체를 트리 구조로 구성하여 복합 객체 안에 복합 객체를 포함하는 구조로 구현한다. |
| **데코레이터****(Decorator)**   | · 객체 간 결합으로 능동적으로 기능들을 확장할 수 있는 패턴이다.· 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현한다. |
| **퍼싸드****(Facade)**          | · 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성하여 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴이다.· 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요하다. |
| **플라이웨이트****(Flyweight)** | · 인스턴스가 필요할 때 매번 생성하는 것이 아니고, 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴이다.· 다수의 유사 객체를 생성하거나 조작할 때 유용한 방식이다. |
| **프록시****(Proxy)**           | · 접근이 어려운 객체와 그 객체에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴이다.· 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 이용된다. |



# **# 행위(Behavioral) 패턴**

클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴이다.

하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화할 수 있도록 도와준다.

| **책임 연쇄****(Chain of Responsibility)** | · 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴이다.· 요청을 처리할 수 있는 각 객체들이 고리로 묶여 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어간다. |
| ------------------------------------------ | ------------------------------------------------------------ |
| **커맨드****(Command)**                    | · 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴이다.· 요청에 사용되는 각종 명령어들을 추상 클레스와 구체(구현) 클래스로 분리하여 단순화 한다. |
| **인터프리터****(InterPreter)**            | · 언어에 문법 표현을 정의하는 패턴이다.· SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용한다. |
| **반복자****(Iterator)**                   | · 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴이다.· 내부 표현 방법의 노출 없이 순차적인 접근이 가능하다. |
| **중재자****(Mediator)**                   | · 수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴이다.· 객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있다. |
| **메멘토****(Memento)**                    | · 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 발생하는 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능이다.· 되돌리기(Ctrl + Z)와 같은 기능 개발 시 이용된다. |
| **옵저버****(Observer)**                   | · 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게도 변화된 상태를 전달하는 패턴이다.· 주로 분산된 시스템 간에 이벤트를 생성 또는 발생하고, 이를 수신해야할 때 이용한다. |
| **상태****(State)**                        | · 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴이다.· 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리한다. |
| **전략****(Strategy)**                     | · 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴이다.· 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용하고, 클라이언트에 영향 없이 알고리즘의 변경이 가능하다. |
| **템플릿 메소드****(Template Method)**     | · 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴이다.· 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양이 줄고 유지 보수가 용이해진다. |
| **방문자****(Visitor)**                    | · 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴이다.· 분리된 처리 기능은 각 클래스를 방문하여 수행한다. |